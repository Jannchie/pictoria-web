<script setup lang="ts">
import { useScroll } from '@vueuse/core'
import type { ComputedRef, MaybeRef } from 'vue'
import { computed, ref, unref, useSlots } from 'vue'
import { useClientHeight, useClientWidth } from '../composables/useClientHeight'

const props = defineProps<{
  gap?: MaybeRef<number>
  wrapperWidth?: MaybeRef<number>
  itemWidth?: MaybeRef<number>
  cols?: MaybeRef<number>
  paddingX?: MaybeRef<number>
  items: MaybeRef<{ width: number, height: number }[]>
  is?: MaybeRef<any>
  yGap?: MaybeRef<number>
  rangeExpand?: MaybeRef<number>
}>()
const rangeExpand = computed(() => unref(props.rangeExpand) ?? 0)
const slots = useSlots()
const gap = computed(() => unref(props.gap) ?? 16)
const paddingX = computed(() => unref(props.paddingX) ?? 0)
const yGap = computed(() => unref(props.yGap) ?? 0)
const wrapper = ref<any>()
const cols = computed(() => {
  return unref(props.cols) ?? 3
})
const wrapperDom = computed<HTMLElement>(() => {
  if (wrapper.value && wrapper.value.$el) {
    return wrapper.value.$el
  }
  return wrapper.value
})

function isArray<T>(val: any): val is T[] {
  return Array.isArray(val)
}

const contentWidth = computed(() => {
  if (props.itemWidth) {
    return unref(props.itemWidth) * cols.value + gap.value * (cols.value - 1) + paddingX.value * 2
  }
  if (props.wrapperWidth) {
    return unref(props.wrapperWidth)
  }
  return wrapperDom.value?.parentElement?.clientWidth ?? 0
})

const itemWidth = computed(() => {
  if (props.itemWidth) {
    return unref(props.itemWidth)
  }
  return (contentWidth.value - paddingX.value * 2 - gap.value * (cols.value - 1)) / cols.value
})

const boundings = computed(() => {
  const itemsVal = unref(props.items)
  return itemsVal.map((d) => {
    const scale = itemWidth.value / d.width
    return {
      width: itemWidth.value,
      height: d.height * scale + yGap.value,
    }
  })
})

const clientWidth = useClientWidth(wrapperDom)
const paddingInner = computed(() => {
  return (clientWidth.value - contentWidth.value) / 2
})
function calculateWaterfallLayout(itemsRef: ComputedRef<{ width: number, height: number }[]>, columnCount: MaybeRef<number>, gap: MaybeRef<number>, paddingX: MaybeRef<number>) {
  const items = unref(itemsRef)
  const columnHeights = Array.from<number>({ length: unref(columnCount) }).fill(0) // 初始化列高度数组
  const itemPositions: {
    x: number
    y: number
    width: number
    height: number
  }[] = [] // 存储每个项目的坐标
  const offset = Math.max(0, contentWidth.value - unref(paddingX) * 2 - itemWidth.value * items.length - unref(gap) * (items.length)) / 2

  for (let i = 0; i < items.length; i++) {
    const item = items[i]
    const columnIndex = columnHeights.indexOf(Math.min(...columnHeights)) // 找到最短的列
    const x = columnIndex * (itemWidth.value + unref(gap)) + unref(paddingX) + offset + unref(paddingInner)
    const y = columnHeights[columnIndex] // 计算 y 坐标
    itemPositions.push({ x, y, width: item.width, height: item.height })
    // 更新列的高度
    columnHeights[columnIndex] += item.height + unref(gap)
  }
  return itemPositions
}

const layoutData = computed(() => {
  return calculateWaterfallLayout(boundings, cols, gap, paddingX)
})

const contentHeight = computed(() => {
  if (!isArray(layoutData.value)) {
    return 0
  }
  return Math.max(...layoutData.value.map(it => it.y + it.height))
})

const allSlots = computed(() => {
  return slots.default?.() ?? []
})

function getItemStyle(i: number) {
  if (!isArray(layoutData.value)) {
    return {}
  }
  const current = layoutData.value[i]
  if (!current) {
    return {}
  }
  return {
    left: `${current.x ?? 0}px`,
    top: `${current.y ?? 0}px`,
    maxWidth: `${itemWidth.value}px`,
  }
}
const clientHeight = useClientHeight(wrapperDom)
const _smooth = ref(false)
const behavior = computed(() => _smooth.value ? 'smooth' : 'auto')
const scroll = useScroll(wrapperDom, {
  behavior,
})
const yRange = computed(() => {
  const yRange = [
    scroll.y.value - rangeExpand.value,
    scroll.y.value + clientHeight.value + rangeExpand.value,
  ]
  return yRange
})

const inRange = computed(() => {
  return layoutData.value.map((it) => {
    const top = it.y
    const bottom = it.y + it.height
    return top >= yRange.value[0] && top <= yRange.value[1] || bottom >= yRange.value[0] && bottom <= yRange.value[1] || top <= yRange.value[0] && bottom >= yRange.value[1]
  })
})

const childrenList = computed(() => {
  const children: any = []
  allSlots.value.forEach((slot, i) => {
    if (isArray(slot.children)) {
      slot.children.forEach((child, i) => {
        if (!inRange.value[i]) {
          return
        }
        children.push([child, i])
      })
    }
    else {
      if (!inRange.value[i]) {
        return
      }
      children.push([slot, i])
    }
  })
  return children
})
const contentDom = ref<HTMLElement>()
defineExpose({
  scroll,
  scrollTo: (top: number, smooth = false) => {
    const prev = _smooth.value
    _smooth.value = smooth
    scroll.y.value = top
    _smooth.value = prev
  },
  wrapperDom,
  contentDom,
  layoutData,
})
const wrapperIs = computed(() => props.is ?? 'div')
</script>

<template>
  <component
    :is="wrapperIs"
    ref="wrapper"
    :style="{
      position: 'relative',
    }"
  >
    <div
      ref="contentDom"
      :style="{
        height: `${contentHeight}px`,
        width: `${clientWidth}px`,
        minHeight: '100%',
        position: 'relative',
      }"
    >
      <div
        v-for="[it, i] in childrenList"
        :key="it"
        :style="getItemStyle(i as number)"
        style="position: absolute;"
      >
        <component
          :is="it"
          :style="{
            width: `${itemWidth}px`,
          }"
        />
      </div>
    </div>
  </component>
</template>
